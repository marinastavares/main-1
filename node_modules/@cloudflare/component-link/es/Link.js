function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import PropTypes from 'prop-types';
import { isDarkMode } from '@cloudflare/style-const';
import { routeTo } from '@cloudflare/util-route-handler';
import { createStyledComponent, filterValidElementProps } from '@cloudflare/style-container';
import { ArrowSwivel } from '@cloudflare/component-arrow-swivel';

const linkStyles = ({
  theme,
  disabled
}) => ({
  display: 'inline-block',
  color: disabled ? theme.colors.gray[4] : isDarkMode() ? theme.colors.blue[3] : theme.colors.blue[4],
  textDecoration: 'none',
  transition: 'all 150ms ease',
  cursor: disabled ? 'default' : 'pointer',
  '& svg': {
    fill: 'currentColor'
  },
  '&:hover': {
    color: disabled ? theme.colors.gray[4] : theme.colors.orange[isDarkMode() ? 3 : 6],
    textDecoration: 'none',
    '& svg': {
      fill: 'currentColor'
    }
  },
  '&:active': {
    color: disabled ? theme.colors.gray[4] : theme.colors.orange[isDarkMode() ? 3 : 6],
    textDecoration: 'none',
    outline: 'none',
    '& svg': {
      fill: 'currentColor'
    }
  },
  '&:focus': {
    color: disabled ? theme.colors.gray[4] : theme.colors.blue[5]
  }
});

class Link extends React.Component {
  constructor(props, context) {
    if (!props.to && !props.onClick) {
      throw new Error('<Link/> requires either a `to` or `onClick` prop');
    }

    super(props, context);

    _defineProperty(this, "ref", node => this.link = node);

    this.handleClick = this.handleClick.bind(this);
    this.focus = this.focus.bind(this);
  }

  focus() {
    this.link.focus();
  }

  handleClick(e) {
    e.preventDefault();

    if (this.props.disabled) {
      return;
    }

    if (this.props.to) {
      routeTo(this.props.to);
    } else {
      this.props.onClick(e);
    }
  }

  render() {
    const _this$props = this.props,
          to = _this$props.to,
          children = _this$props.children,
          disabled = _this$props.disabled,
          isActive = _this$props.isActive,
          expandable = _this$props.expandable,
          props = _objectWithoutProperties(_this$props, ["to", "children", "disabled", "isActive", "expandable"]);

    if (!props.href) {
      props.href = to || '#!';
    }

    if (!props.role) {
      if (to) {
        props.role = 'link';
      } else if (!to) {
        props.role = 'button';
      }
    }

    if (disabled) {
      props.disabled = true;
    }

    props.onClick = this.handleClick;
    const filteredProps = filterValidElementProps('a', props);
    return /*#__PURE__*/React.createElement("a", _extends({
      ref: this.ref
    }, filteredProps, {
      "data-testid": this.props.testId
    }), children, expandable && /*#__PURE__*/React.createElement(ArrowSwivel, {
      isActive: isActive
    }));
  }

}

Link.propTypes = {
  to: PropTypes.string,
  href: PropTypes.string,
  onClick: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  disabled: PropTypes.bool,
  children: PropTypes.node,
  role: PropTypes.string,
  expandable: PropTypes.bool,
  isActive: PropTypes.bool,
  testId: PropTypes.string
};
Link.displayName = 'Link';
export default createStyledComponent(linkStyles, Link);