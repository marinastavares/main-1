export * from './enumerable'; // (A - keys of B)
// In set theory, this would be the set complement A âˆ– B (https://en.wikipedia.org/wiki/Complement_(set_theory)#Relative_complement)
// Example:
//      type A = {a: string, b: number, c: boolean}
//      type B = {b: number}
//      type result = Omit<A, keyof B> = {a: string, c: boolean}

/**
 * Generates the typings for usage with Object.keys
 *
 *  @example
 *  const Locations = { "Cina": "Austin", "John": "Austin", "Kevin": "Austin", "Nicky": "San Francisco", "Robert": "San Francisco" }
 *  const KeysFromLocations = objectKeys(Locations)
 */
export function objectKeys(t) {
  return Object.keys(t);
}
/*
 * Get a type of awaited Promise value.
 *
 * @example
 * type StringPromise = Promise<string>
 *
 * type Value = PromiseType<StringPromise> // string
 */

/**
 * Should be used in the `default:` case of a switch.
 * Will cause a compilation-time type error if the switch is not exhaustive.
 * See https://www.typescriptlang.org/docs/handbook/advanced-types.html
 *
 * @param x
 * @param returnValue If provided, doesn't throw at runtime, but returns this value.
 *
 * @example
 * type Type = "error" | "success" | "info" | "warning"
 *
 * const getIcon = (type: Type) => {
 *   switch (type) {
 *     case 'success':
 *       return 'ok';
 *     case 'error':
 *       return 'sad';
 *     case 'info':
 *       return 'info-sign';
 *     default:
 *       return assertNever(type); // Shows error, because 'warning' is not handled.
 *   }
 * };
 */
export const assertNever = (x, returnValue) => {
  if (returnValue !== undefined) {
    throw new Error('Unexpected object: ' + x);
  } else {
    return returnValue;
  }
};