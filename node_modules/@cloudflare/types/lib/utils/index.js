"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  objectKeys: true,
  assertNever: true
};
exports.objectKeys = objectKeys;
exports.assertNever = void 0;

var _enumerable = require("./enumerable");

Object.keys(_enumerable).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _enumerable[key];
    }
  });
});

/**
 * Generates the typings for usage with Object.keys
 *
 *  @example
 *  const Locations = { "Cina": "Austin", "John": "Austin", "Kevin": "Austin", "Nicky": "San Francisco", "Robert": "San Francisco" }
 *  const KeysFromLocations = objectKeys(Locations)
 */
function objectKeys(t) {
  return Object.keys(t);
}
/*
 * Get a type of awaited Promise value.
 *
 * @example
 * type StringPromise = Promise<string>
 *
 * type Value = PromiseType<StringPromise> // string
 */


/**
 * Should be used in the `default:` case of a switch.
 * Will cause a compilation-time type error if the switch is not exhaustive.
 * See https://www.typescriptlang.org/docs/handbook/advanced-types.html
 *
 * @param x
 * @param returnValue If provided, doesn't throw at runtime, but returns this value.
 *
 * @example
 * type Type = "error" | "success" | "info" | "warning"
 *
 * const getIcon = (type: Type) => {
 *   switch (type) {
 *     case 'success':
 *       return 'ok';
 *     case 'error':
 *       return 'sad';
 *     case 'info':
 *       return 'info-sign';
 *     default:
 *       return assertNever(type); // Shows error, because 'warning' is not handled.
 *   }
 * };
 */
var assertNever = function assertNever(x, returnValue) {
  if (returnValue !== undefined) {
    throw new Error('Unexpected object: ' + x);
  } else {
    return returnValue;
  }
};

exports.assertNever = assertNever;