"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.colorProps = exports.borderWidthProps = exports.borderStyleProps = exports.borderRadiusProps = void 0;
exports.filterStyleProps = filterStyleProps;
exports.styleRuleProps = exports.spacingProps = exports.sizeProps = void 0;

var _reactDisplayName = _interopRequireDefault(require("react-display-name"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _fela = require("fela");

var _createComponent = _interopRequireDefault(require("./createComponent"));

var _styleConst = require("@cloudflare/style-const");

var _types = require("./types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var sizePropType = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.array, _propTypes.default.number]);

var scalePropType = _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number, _propTypes.default.array]);

var longhandSpacingProps = ['margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'gap'];
var shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};
var spacingProps = [].concat(longhandSpacingProps, _toConsumableArray((0, _types.objectKeys)(shorthandSpacingProps)));
exports.spacingProps = spacingProps;
var sizeProps = ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'];
exports.sizeProps = sizeProps;
var colorProps = ['color', 'backgroundColor', 'borderColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomColor'];
exports.colorProps = colorProps;
var borderStyleProps = ['borderStyle', 'borderTopStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle'];
exports.borderStyleProps = borderStyleProps;
var borderWidthProps = ['borderWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth'];
exports.borderWidthProps = borderWidthProps;
var borderRadiusProps = ['borderRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderbottomRightRadius'];
exports.borderRadiusProps = borderRadiusProps;
var additionalProps = ['fontSize', 'fontWeight', 'textAlign', 'display', 'width', 'verticalAlign', 'alignItems', 'alignSelf', 'justifyContent', 'textDecoration', 'textTransform', 'boxSizing', 'cursor', 'flexDirection', 'flexBasis', 'flexGrow', 'gridTemplateColumns'];
var styleRuleProps = [].concat(_toConsumableArray(spacingProps), sizeProps, colorProps, borderStyleProps, borderWidthProps, borderRadiusProps, additionalProps);
exports.styleRuleProps = styleRuleProps;
var stylesRulePropsSet = new Set(styleRuleProps); // Function to remove styling attributes from a Props object

function filterStyleProps(props) {
  var newProps;
  var properties = Object.keys(props);
  properties.forEach(function (property) {
    if (stylesRulePropsSet.has(property)) {
      newProps = newProps || _objectSpread({}, props);
      delete newProps[property];
    }
  });
  return newProps || props;
}

// gotta broaden from Set<StyleRuleProp> to a ReadonlySet<string> so we can check
// if arbitrary strings are in it via propsSet.has(maybeStyleRuleProp)
var propsSet = new Set(styleRuleProps); // Function to construct the prop types object

var makePropTypes = function makePropTypes() {
  var propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType,
    width: sizePropType,
    verticalAlign: sizePropType
  };

  for (var _i = 0, _arr = [].concat(_toConsumableArray(spacingProps), borderWidthProps, borderRadiusProps); _i < _arr.length; _i++) {
    var prop = _arr[_i];
    propTypes[prop] = scalePropType;
  }

  for (var _i2 = 0, _arr2 = [].concat(colorProps, borderStyleProps); _i2 < _arr2.length; _i2++) {
    var _prop = _arr2[_i2];
    propTypes[_prop] = _propTypes.default.string;
  }

  var _iterator = _createForOfIteratorHelper(sizeProps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _prop2 = _step.value;
      propTypes[_prop2] = sizePropType;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return propTypes;
};

var styledPropTypes = makePropTypes(); // Fela rule which turns component props into a style object

var propsRule = function propsRule(props) {
  return Object.keys(props).filter(function (prop) {
    return propsSet.has(prop);
  }).reduce(function (o, prop) {
    return o[prop] = props[prop], o;
  }, {});
}; // Static breakpoints


var bp = [null, "tablet", "desktop"]; // Ensure value is an array

var arr = function arr(n) {
  return Array.isArray(n) ? n : [n];
}; // Wrap a value in an object with a property name
// assignValueToProperty("margin")(32) returns {margin: 32}


var assignValueToProperty = function assignValueToProperty(property) {
  return function (val) {
    return _defineProperty({}, property, val);
  };
}; // Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]


var media = function media(style, i) {
  if (style === null || style === undefined) return null;
  var breakpoint = bp[i];
  return breakpoint ? _defineProperty({}, breakpoint, style) : style;
};

// Recursive object merge
var merge = function merge(a, b) {
  return Object.assign({}, a, b, Object.keys(b).reduce(function (obj, key) {
    return Object.assign(obj, _defineProperty({}, key, a[key] !== null && _typeof(a[key]) === 'object' ? merge(a[key], b[key]) : b[key]));
  }, {}));
};

var processRules = function processRules(customRules) {
  var rules = _objectSpread({}, customRules); // Expand shorthand spacing properties


  ['padding', 'margin'].forEach(function (property) {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(function (position) {
        var attr = "".concat(property).concat(position); // Don't overwrite pre-existing longhand properties

        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  }); // Expand custom shorthand spacing properties

  Object.keys(rules).filter(function (property) {
    return Object.keys(shorthandSpacingProps).includes(property);
  }).forEach(function (property) {
    Object.assign(rules, shorthandSpacingProps[property].reduce(function (a, b) {
      a[b] = rules[property];
      return a;
    }, {}));
    delete rules[property];
  }); // Convert spacing scales

  rules = Object.keys(rules).filter(function (property) {
    return spacingProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      return _styleConst.variables.space[val] || val;
    }).map(assignValueToProperty(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // Convert colors to theme

  rules = Object.keys(rules).filter(function (property) {
    return colorProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      // Handle nested '.' syntax
      if (val && val.includes('.')) {
        // Attempt to access nested values, otherwise return what was passed
        try {
          return val.split('.').reduce(function (acc, part) {
            return acc[part];
          }, _styleConst.variables.colors);
        } catch (e) {
          return val;
        }
      } else if (typeof _styleConst.variables.colors[val] === 'string') {
        return _styleConst.variables.colors[val];
      }

      return val;
    }).map(assignValueToProperty(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // font-size

  if (rules.fontSize) {
    var fontSize = arr(rules.fontSize).map(function (val) {
      return _styleConst.variables.fontSizes[val] || val;
    }).map(assignValueToProperty('fontSize')).map(media).reduce(merge, {});
    delete rules.fontSize;
    rules = merge(rules, fontSize);
  } // display


  if (rules.display) {
    var display = arr(rules.display).map(assignValueToProperty('display')).map(media).reduce(merge, {});
    delete rules.display;
    rules = merge(rules, display);
  } // width


  if (rules.width) {
    var width = arr(rules.width).map(assignValueToProperty('width')).map(media).reduce(merge, {});
    delete rules.width;
    rules = merge(rules, width);
  }

  return rules;
};

var emptyRule = function emptyRule() {
  return {};
};

var makeStyledRule = function makeStyledRule(rule) {
  var combinedRules = (0, _fela.combineRules)(rule !== null && rule !== void 0 ? rule : emptyRule, propsRule);
  return function (props, renderer) {
    return processRules(combinedRules(props, renderer));
  };
};

function createStyledComponent(rule, type, passthroughProps) {
  var styledRule = makeStyledRule(rule);
  var Component = (0, _createComponent.default)(styledRule, type, passthroughProps);
  Component.propTypes = styledPropTypes;

  if (typeof type === 'function') {
    Component.displayName = (0, _reactDisplayName.default)(type);
  }

  return Component;
}

var _default = createStyledComponent;
exports.default = _default;