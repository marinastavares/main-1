function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import getReactDisplayName from 'react-display-name';
import PropTypes from 'prop-types';
import { combineRules } from 'fela';
import createComponent from './createComponent';
import { variables as theme } from '@cloudflare/style-const'; // eslint-disable-line behance/no-deprecated

import { objectKeys } from './types';
var sizePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.array, PropTypes.number]);
var scalePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]);
var longhandSpacingProps = ['margin', 'marginLeft', 'marginRight', 'marginTop', 'marginBottom', 'padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom', 'gap'];
var shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};
var spacingProps = [...longhandSpacingProps, ...objectKeys(shorthandSpacingProps)];
var sizeProps = ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'];
var colorProps = ['color', 'backgroundColor', 'borderColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomColor'];
var borderStyleProps = ['borderStyle', 'borderTopStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle'];
var borderWidthProps = ['borderWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth'];
var borderRadiusProps = ['borderRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderbottomRightRadius'];
var additionalProps = ['fontSize', 'fontWeight', 'textAlign', 'display', 'width', 'verticalAlign', 'alignItems', 'alignSelf', 'justifyContent', 'textDecoration', 'textTransform', 'boxSizing', 'cursor', 'flexDirection', 'flexBasis', 'flexGrow', 'gridTemplateColumns'];
export var styleRuleProps = [...spacingProps, ...sizeProps, ...colorProps, ...borderStyleProps, ...borderWidthProps, ...borderRadiusProps, ...additionalProps];
var stylesRulePropsSet = new Set(styleRuleProps); // Function to remove styling attributes from a Props object

export function filterStyleProps(props) {
  var newProps;
  var properties = Object.keys(props);
  properties.forEach(property => {
    if (stylesRulePropsSet.has(property)) {
      newProps = newProps || _objectSpread({}, props);
      delete newProps[property];
    }
  });
  return newProps || props;
}
// gotta broaden from Set<StyleRuleProp> to a ReadonlySet<string> so we can check
// if arbitrary strings are in it via propsSet.has(maybeStyleRuleProp)
var propsSet = new Set(styleRuleProps); // Function to construct the prop types object

var makePropTypes = () => {
  var propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType,
    width: sizePropType,
    verticalAlign: sizePropType
  };

  for (var prop of [...spacingProps, ...borderWidthProps, ...borderRadiusProps]) {
    propTypes[prop] = scalePropType;
  }

  for (var _prop of [...colorProps, ...borderStyleProps]) {
    propTypes[_prop] = PropTypes.string;
  }

  for (var _prop2 of sizeProps) {
    propTypes[_prop2] = sizePropType;
  }

  return propTypes;
};

var styledPropTypes = makePropTypes(); // Fela rule which turns component props into a style object

var propsRule = props => Object.keys(props).filter(prop => propsSet.has(prop)).reduce((o, prop) => (o[prop] = props[prop], o), {}); // Static breakpoints


var bp = [null, "tablet", "desktop"]; // Ensure value is an array

var arr = n => Array.isArray(n) ? n : [n]; // Wrap a value in an object with a property name
// assignValueToProperty("margin")(32) returns {margin: 32}


var assignValueToProperty = property => val => ({
  [property]: val
}); // Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]


var media = (style, i) => {
  if (style === null || style === undefined) return null;
  var breakpoint = bp[i];
  return breakpoint ? {
    [breakpoint]: style
  } : style;
};

// Recursive object merge
var merge = (a, b) => Object.assign({}, a, b, Object.keys(b).reduce((obj, key) => Object.assign(obj, {
  [key]: a[key] !== null && typeof a[key] === 'object' ? merge(a[key], b[key]) : b[key]
}), {}));

var processRules = customRules => {
  var rules = _objectSpread({}, customRules); // Expand shorthand spacing properties


  ['padding', 'margin'].forEach(property => {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(position => {
        var attr = "".concat(property).concat(position); // Don't overwrite pre-existing longhand properties

        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  }); // Expand custom shorthand spacing properties

  Object.keys(rules).filter(property => Object.keys(shorthandSpacingProps).includes(property)).forEach(property => {
    Object.assign(rules, shorthandSpacingProps[property].reduce((a, b) => {
      a[b] = rules[property];
      return a;
    }, {}));
    delete rules[property];
  }); // Convert spacing scales

  rules = Object.keys(rules).filter(property => spacingProps.includes(property)).map(property => {
    var propValues = arr(rules[property]).map(val => theme.space[val] || val).map(assignValueToProperty(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // Convert colors to theme

  rules = Object.keys(rules).filter(property => colorProps.includes(property)).map(property => {
    var propValues = arr(rules[property]).map(val => {
      // Handle nested '.' syntax
      if (val && val.includes('.')) {
        // Attempt to access nested values, otherwise return what was passed
        try {
          return val.split('.').reduce((acc, part) => acc[part], theme.colors);
        } catch (e) {
          return val;
        }
      } else if (typeof theme.colors[val] === 'string') {
        return theme.colors[val];
      }

      return val;
    }).map(assignValueToProperty(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // font-size

  if (rules.fontSize) {
    var fontSize = arr(rules.fontSize).map(val => theme.fontSizes[val] || val).map(assignValueToProperty('fontSize')).map(media).reduce(merge, {});
    delete rules.fontSize;
    rules = merge(rules, fontSize);
  } // display


  if (rules.display) {
    var display = arr(rules.display).map(assignValueToProperty('display')).map(media).reduce(merge, {});
    delete rules.display;
    rules = merge(rules, display);
  } // width


  if (rules.width) {
    var width = arr(rules.width).map(assignValueToProperty('width')).map(media).reduce(merge, {});
    delete rules.width;
    rules = merge(rules, width);
  }

  return rules;
};

var emptyRule = () => ({});

var makeStyledRule = rule => {
  var combinedRules = combineRules(rule !== null && rule !== void 0 ? rule : emptyRule, propsRule);
  return (props, renderer) => processRules(combinedRules(props, renderer));
};

function createStyledComponent(rule, type, passthroughProps) {
  var styledRule = makeStyledRule(rule);
  var Component = createComponent(styledRule, type, passthroughProps);
  Component.propTypes = styledPropTypes;

  if (typeof type === 'function') {
    Component.displayName = getReactDisplayName(type);
  }

  return Component;
}

export default createStyledComponent;
export { colorProps, spacingProps, sizeProps, borderStyleProps, borderWidthProps, borderRadiusProps };