import { ComponentType, CSSProperties, DetailedHTMLProps, Ref, HTMLAttributes, ComponentClass, ForwardRefExoticComponent, PropsWithoutRef } from 'react';
import { TMultiRuleObject, TMultiRule } from 'fela-tools';
import { variables } from '@cloudflare/style-const';
import type { IRenderer, IStyle } from 'fela';
import { FelaWithThemeProps } from 'react-fela';
export { ThemeProvider } from 'react-fela';
export declare type ElementTag = keyof JSX.IntrinsicElements;
export declare type BaseType = ElementTag | ComponentType<any>;
export declare type KeyList<T> = Extract<keyof T, string>[];
export declare type PassthroughProps<P> = KeyList<P> | ((props: P) => KeyList<P>);
export declare function objectKeys<T>(t: T): KeyList<T>;
export declare type TRuleCSSPropsAndSelectors = CSSProperties | {
    [selector: string]: CSSProperties;
};
export declare type TRule<T = {}> = (attrs?: T) => TRuleCSSPropsAndSelectors;
export declare type TTheme<P> = P | ((props: P) => {
    [key: string]: any;
} & CSSProperties);
export declare type ThemeProp = FelaWithThemeProps<TStandardTheme>;
export interface WithTheme {
    <Props>(component: ComponentType<ThemeProp & Props>): ComponentType<Props>;
}
/**
 * Helper type for intersecting an interface with ThemeProp
 * to get access to the 'theme' prop within a rule function
 */
export declare type StyleProps<Base extends BaseType = 'div', AdditionalStyleProps = {}> = AdditionalStyleProps & InferProps<Base> & ThemeProp;
/**
 * Rule function that accepts props and theme and returns an object
 * with CSS rules.
 */
export declare type StyleFn<Base extends BaseType = 'div', AdditionalStyleProps = {}> = (props: StyleProps<Base, AdditionalStyleProps>, renderer?: IRenderer) => CSSWithSelectors;
/**
 * Type that allows for arbitrary keys to be used as selectors
 * while preserving intellisense for standard CSS properties
 */
export declare type CSSWithSelectors = {
    [key: string]: CSSWithSelectors;
} | IStyle;
/**
 * Type helper providing the innerRef prop
 */
export declare type InnerRefProp<Base extends BaseType> = {
    innerRef?: Ref<RefType<Base>>;
};
/**
 * Type helper that simply infers the type of T. This is used as
 * a hack to infer the type *before* passing the Base type into
 * StyleFn because if you don't then the type inference can be
 * wrong when it gets intersected with types inside StyleFn.
 */
export declare type ForceInference<T> = T extends infer A ? A : never;
/**
 * Type helper for inferring what the ref type should be based
 * on the Base type. First it checks to see if it's an element,
 * and if so, infers the element's type. Next it checks to see
 * if it's a component that already has an innerRef (from another
 * component created with createComponent). Next it needs to check
 * if it's class component, and if so returns the instance type
 * of the class componentn. Lastly, it looks to see if it's a
 * component created with forwardRef and infers the ref type.
 * If it was none of those things (just a regular function
 * component) then it returns never since there is no ref type
 * for regular function components.
 */
export declare type RefType<Base extends BaseType> = Base extends ElementTag ? ElementType<Base> : InferProps<Base> extends {
    innerRef?: Ref<infer InnerRef>;
} ? InnerRef : Base extends ComponentClass<any> ? InstanceType<Base> : Base extends ForwardRefExoticComponent<{
    ref?: Ref<infer ForwardedRef>;
}> ? ForwardedRef : never;
/**
 * Type helper for inferring props. Cannot use ComponentProps from
 * React here because we lose {children?: ReactNode} when it infers
 * props using JSXElementConstructor. Additionally, we want to make
 * sure we don't include 'ref' as a prop which can be found on
 * components created with forwardRef and props for elements on
 * JSX.IntrinsicElements
 */
export declare type InferProps<Base extends BaseType> = PropsWithoutRef<Base extends ElementTag ? JSX.IntrinsicElements[Base] : Base extends ComponentType<infer Props> ? Props : never>;
export declare type TStandardTheme = typeof variables;
/**
 * Type helper for inferring an HTMLElement type based on the element
 * tag type passed in.
 */
export declare type ElementType<Element extends ElementTag> = JSX.IntrinsicElements[Element] extends DetailedHTMLProps<HTMLAttributes<infer E>, any> ? E : never;
export declare type TStaticRule = (attr: {
    theme: TStandardTheme;
}) => string;
export declare type StyleFunctions = TMultiRule | TMultiRuleObject;
export declare type ConnectedComponentStyles<Styles> = Styles extends StyleFunctions ? {
    styles: {
        [Style in keyof Styles]: string;
    };
} : never;
