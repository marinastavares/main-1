export class Interpolation<Param extends string> {
  value: string;
  keys: Param[];

  constructor(value: string, keys: Param[]) {
    this.value = value;
    this.keys = keys;
  }

  toString() {
    return this.value;
  }

  toJSON() {
    return this.value;
  }
}

export type Catalog = { [key: string]: string | Interpolation<any> | Catalog };

type Keys<T extends Catalog> = {
  [K in keyof T]: T[K] extends Interpolation<any>
    ? T[K]
    : T[K] extends string
    ? K
    : T[K] extends Catalog
    ? Keys<T[K]>
    : never;
};

export type TranslationPrepareResult<T extends Catalog> = {
  keys: Keys<T>;
  translations: { [key: string]: string };
  namespace: string;
};

/**
 * Extracts the union of all the leaf keys in a catalog
 */
export type KeysType<T> = {
  [K in keyof T]: T[K] extends Interpolation<any>
    ? T[K]
    : T[K] extends object
    ? KeysType<T[K]>
    : T[K];
}[keyof T];

export enum SupportedLocales {
  en_US = 'en-US',
  de_DE = 'de-DE',
  zh_CN = 'zh-CN',
  fr_FR = 'fr-FR',
  ja_JP = 'ja-JP',
  es_ES = 'es-ES',
  es_CL = 'es-CL',
  es_EC = 'es-EC',
  es_MX = 'es-MX',
  es_PE = 'es-PE',
  it_IT = 'it-IT',
  ko_KR = 'ko-KR',
  pt_BR = 'pt-BR',
  zh_TW = 'zh-TW'
}

// A Locale is the string actually used in the frontend, like 'en-US'
// This is aliased to make a slightly easier to read type
export type Locale = SupportedLocales;
export type LocaleKey = keyof typeof SupportedLocales;

export type TLoadPhrases = (language: Locale) => Promise<IPhrases>;

export interface IPhrases {
  [key: string]: string | IPhrases;
}
export type TPhrasesModule =
  | (IPhrases & {
      default: IPhrases;
    })
  | Partial<TranslationPrepareResult<any>>;

export type TLoadLocales = {
  [locale in SupportedLocales]: () => Promise<TPhrasesModule>;
};
