export declare class Interpolation<Param extends string> {
    value: string;
    keys: Param[];
    constructor(value: string, keys: Param[]);
    toString(): string;
    toJSON(): string;
}
export declare type Catalog = {
    [key: string]: string | Interpolation<any> | Catalog;
};
declare type Keys<T extends Catalog> = {
    [K in keyof T]: T[K] extends Interpolation<any> ? T[K] : T[K] extends string ? K : T[K] extends Catalog ? Keys<T[K]> : never;
};
export declare type TranslationPrepareResult<T extends Catalog> = {
    keys: Keys<T>;
    translations: {
        [key: string]: string;
    };
    namespace: string;
};
/**
 * Extracts the union of all the leaf keys in a catalog
 */
export declare type KeysType<T> = {
    [K in keyof T]: T[K] extends Interpolation<any> ? T[K] : T[K] extends object ? KeysType<T[K]> : T[K];
}[keyof T];
export declare enum SupportedLocales {
    en_US = "en-US",
    de_DE = "de-DE",
    zh_CN = "zh-CN",
    fr_FR = "fr-FR",
    ja_JP = "ja-JP",
    es_ES = "es-ES",
    es_CL = "es-CL",
    es_EC = "es-EC",
    es_MX = "es-MX",
    es_PE = "es-PE",
    it_IT = "it-IT",
    ko_KR = "ko-KR",
    pt_BR = "pt-BR",
    zh_TW = "zh-TW"
}
export declare type Locale = SupportedLocales;
export declare type LocaleKey = keyof typeof SupportedLocales;
export declare type TLoadPhrases = (language: Locale) => Promise<IPhrases>;
export interface IPhrases {
    [key: string]: string | IPhrases;
}
export declare type TPhrasesModule = (IPhrases & {
    default: IPhrases;
}) | Partial<TranslationPrepareResult<any>>;
export declare type TLoadLocales = {
    [locale in SupportedLocales]: () => Promise<TPhrasesModule>;
};
export {};
