"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _styleContainer = require("@cloudflare/style-container");

var _propertiesSpec = _interopRequireDefault(require("./propertiesSpec"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var propertyNames = Object.keys(_propertiesSpec.default); // Generates styles given the provided props.
//
// This is driven by the metadata provided in propertiesSpec
// and produces a data structure like this:
//
// {
//   margin: props.margin || props.theme['margin']
//   width: props.width || props.theme['width']
//   ...
// }
//
// See propertySpec.js for more detail
//

var styles = function styles(props) {
  var styles = {};
  var propKeys = Object.keys(props);
  propKeys.forEach(function (name) {
    // Lookup the spec for the property
    var spec = _propertiesSpec.default[name]; // Ignore non-style props

    if (spec === undefined) {
      return;
    } // Get the style value from props


    var value = props[name]; // pre-process the value with all pre-processors

    if (spec.preprocessWith) {
      spec.preprocessWith.forEach(function (fn) {
        value = fn(value);
      });
    }

    styles[name] = value;
  }); // Only do checks in dev mode

  if (process.env.NODE_ENV !== 'production') {
    checkForViolations(styles);
  }

  return styles;
};

var Box = (0, _styleContainer.createStyledComponent)(styles, 'div');

var checkForViolations = function checkForViolations(props) {
  // Check for conflicts given the spec's conflictsWith property
  // See propertySpec.js for more detail
  propertyNames.forEach(function (propName) {
    var spec = _propertiesSpec.default[propName];
    if (!props[propName] || !spec.conflictsWith) return;
    spec.conflictsWith.forEach(function (otherPropName) {
      if (props[propName] && props[otherPropName]) {
        var msg = "".concat(propName, " cannot be set in conjunction with ").concat(otherPropName);
        console.error(msg);
      }
    });
  }); // TODO: To pull this check off, we'll need re-evaluate our baseline.
  // current is 22.5px
  // checkLineHeightViolations(props);
};
/*
const checkLineHeightViolations = props => {
  const rem2px = rem => {
    return parseFloat(rem) * props.fontSize;
  };

  const baseline = props.lineHeight * props.fontSize;

  // Calculate total margin, padding, and border
  let totalMargin = 0;
  if (props.margin) {
    totalMargin = rem2px(props.margin);
  } else {
    totalMargin += rem2px(props.marginTop) || 0;
    totalMargin += rem2px(props.marginBottom) || 0;
  }

  let totalPadding = 0;
  if (props.padding) {
    totalPadding = rem2px(props.padding);
  } else {
    totalPadding += rem2px(props.paddingTop) || 0;
    totalPadding += rem2px(props.paddingBottom) || 0;
  }

  let totalBorder = 0;
  if (props.borderHeight) {
    totalBorder = rem2px(props.borderHeight);
  } else {
    totalBorder += rem2px(props.borderTopHeight) || 0;
    totalBorder += rem2px(props.borderBottomHeight) || 0;
  }

  // Warn the user if the total spacing isn't a multiple of the baseline
  const spacing = totalMargin + totalBorder + totalPadding;
  if (spacing && baseline % spacing !== 0) {
    console.warn(
      `Spacing from padding, border, and margin surrounding element should be a multiple of baseline ${baseline}.`
    );
  }
};
*/
// Extract proptypes from the propertiesSpec


var extractPropTypes = function extractPropTypes() {
  var propTypes = {}; // Loop through all property specs and pluck the prop type

  propertyNames.forEach(function (name) {
    propTypes[name] = _propertiesSpec.default[name].propType;
  });
  return propTypes;
};

Box.propTypes = _objectSpread({
  className: _propTypes.default.string,
  children: _propTypes.default.node
}, extractPropTypes());
Box.displayName = 'Box';
var _default = Box;
exports.default = _default;