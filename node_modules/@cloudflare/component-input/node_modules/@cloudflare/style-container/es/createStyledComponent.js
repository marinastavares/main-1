function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import PropTypes from 'prop-types';
import createComponent from './createComponent';
import { combineRules } from '.';
import { variables as theme } from '@cloudflare/style-const'; // eslint-disable-line behance/no-deprecated

var sizePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.array, PropTypes.number]);
var scalePropType = PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]);
var shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};
var spacingProps = ['padding', 'paddingLeft', 'paddingRight', 'paddingBottom', 'paddingTop', 'margin', 'marginLeft', 'marginRight', 'marginBottom', 'marginTop'].concat(_toConsumableArray(Object.keys(shorthandSpacingProps)));
var sizeProps = ['width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight'];
var colorProps = ['color', 'backgroundColor', 'borderColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'borderBottomColor'];
var borderStyleProps = ['borderStyle', 'borderTopStyle', 'borderBottomStyle', 'borderLeftStyle', 'borderRightStyle'];
var borderWidthProps = ['borderWidth', 'borderTopWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderRightWidth'];
var borderRadiusProps = ['borderRadius', 'borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomLeftRadius', 'borderbottomRightRadius'];
var propsSet = new Set(spacingProps.concat(sizeProps, colorProps, borderStyleProps, borderWidthProps, borderRadiusProps, 'fontSize', 'textAlign', 'display')); // Function to construct the prop types object

var makePropTypes = function makePropTypes() {
  var propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType
  };
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = spacingProps.concat(borderWidthProps, borderRadiusProps)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;
      propTypes[prop] = scalePropType;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = colorProps.concat(borderStyleProps)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _prop = _step2.value;
      propTypes[_prop] = PropTypes.string;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  for (var _i = 0; _i < sizeProps.length; _i++) {
    var _prop2 = sizeProps[_i];
    propTypes[_prop2] = sizePropType;
  }

  return propTypes;
};

var styledPropTypes = makePropTypes(); // Fela rule which turns component props into a style object

var propsRule = function propsRule(props) {
  return Object.keys(props).filter(function (prop) {
    return propsSet.has(prop);
  }).reduce(function (o, prop) {
    return o[prop] = props[prop], o;
  }, {});
}; // Static breakpoints


var bp = [null, "tablet", "desktop"]; // Ensure value is an array

var arr = function arr(n) {
  return Array.isArray(n) ? n : [n];
}; // Tranform value array into object array
// [32, 64] into [{margin: 32}, {margin: 64}]


var dec = function dec(props) {
  return function (val) {
    return arr(props).reduce(function (acc, prop) {
      return acc[prop] = val, acc;
    }, {});
  };
}; // Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]


var media = function media(d, i) {
  return d !== undefined && d !== null ? bp[i] ? _defineProperty({}, bp[i], d) : d : null;
}; // Recursive object merge


var merge = function merge(a, b) {
  return Object.assign({}, a, b, Object.keys(b).reduce(function (obj, key) {
    return Object.assign(obj, _defineProperty({}, key, a[key] !== null && _typeof(a[key]) === 'object' ? merge(a[key], b[key]) : b[key]));
  }, {}));
};

var processRules = function processRules(customRules) {
  var rules = _objectSpread({}, customRules); // Expand shorthand spacing properties


  ['padding', 'margin'].forEach(function (property) {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(function (position) {
        var attr = "".concat(property).concat(position); // Don't overwrite pre-existing longhand properties

        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  }); // Expand custom shorthand spacing properties

  Object.keys(rules).filter(function (property) {
    return Object.keys(shorthandSpacingProps).includes(property);
  }).forEach(function (property) {
    Object.assign(rules, shorthandSpacingProps[property].reduce(function (a, b) {
      a[b] = rules[property];
      return a;
    }, {}));
    delete rules[property];
  }); // Convert spacing scales

  rules = Object.keys(rules).filter(function (property) {
    return spacingProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      return theme.space[val] || val;
    }).map(dec(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // Convert colors to theme

  rules = Object.keys(rules).filter(function (property) {
    return colorProps.includes(property);
  }).map(function (property) {
    var propValues = arr(rules[property]).map(function (val) {
      // Handle nested '.' syntax
      if (val && val.includes('.')) {
        // Attempt to access nested values, otherwise return what was passed
        try {
          return val.split('.').reduce(function (acc, part) {
            return acc[part];
          }, theme.colors);
        } catch (e) {
          return val;
        }
      } else if (typeof theme.colors[val] === 'string') {
        return theme.colors[val];
      }

      return val;
    }).map(dec(property)).map(media).reduce(merge, {});
    delete rules[property];
    return propValues;
  }).reduce(merge, rules); // font-size

  if (rules.fontSize) {
    var fontSize = arr(rules.fontSize).map(function (val) {
      return theme.fontSizes[val] || val;
    }).map(dec('fontSize')).map(media).reduce(merge, {});
    delete rules.fontSize;
    rules = merge(rules, fontSize);
  } // display


  if (rules.display) {
    var display = arr(rules.display).map(dec('display')).map(media).reduce(merge, {});
    delete rules.display;
    rules = merge(rules, display);
  }

  return rules;
};

var emptyRule = function emptyRule() {
  return {};
};

var makeStyledRule = function makeStyledRule() {
  var rule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyRule;
  var combinedRules = combineRules(rule, propsRule);
  return function (props, renderer) {
    return processRules(combinedRules(props, renderer));
  };
};

function createStyledComponent(rule) {
  var styledRule = makeStyledRule(rule);

  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  var Component = createComponent.apply(void 0, [styledRule].concat(rest));
  Component.propTypes = styledPropTypes;
  return Component;
}

export default createStyledComponent;
export { colorProps, spacingProps, sizeProps, borderStyleProps, borderWidthProps, borderRadiusProps };