import PropTypes from 'prop-types';
import createComponent from './createComponent';
import { combineRules } from '.';

import { variables as theme } from '@cloudflare/style-const'; // eslint-disable-line behance/no-deprecated

const sizePropType = PropTypes.oneOfType([
  PropTypes.string,
  PropTypes.array,
  PropTypes.number
]);
const scalePropType = PropTypes.oneOfType([
  PropTypes.string,
  PropTypes.number,
  PropTypes.array
]);

const shorthandSpacingProps = {
  m: ['margin'],
  ml: ['marginLeft'],
  mr: ['marginRight'],
  mt: ['marginTop'],
  mb: ['marginBottom'],
  mx: ['marginLeft', 'marginRight'],
  my: ['marginTop', 'marginBottom'],
  p: ['padding'],
  pl: ['paddingLeft'],
  pr: ['paddingRight'],
  pt: ['paddingTop'],
  pb: ['paddingBottom'],
  px: ['paddingLeft', 'paddingRight'],
  py: ['paddingTop', 'paddingBottom']
};

const spacingProps = [
  'padding',
  'paddingLeft',
  'paddingRight',
  'paddingBottom',
  'paddingTop',
  'margin',
  'marginLeft',
  'marginRight',
  'marginBottom',
  'marginTop',
  ...Object.keys(shorthandSpacingProps)
];

const sizeProps = [
  'width',
  'height',
  'minWidth',
  'minHeight',
  'maxWidth',
  'maxHeight'
];

const colorProps = [
  'color',
  'backgroundColor',
  'borderColor',
  'borderLeftColor',
  'borderRightColor',
  'borderTopColor',
  'borderBottomColor'
];

const borderStyleProps = [
  'borderStyle',
  'borderTopStyle',
  'borderBottomStyle',
  'borderLeftStyle',
  'borderRightStyle'
];

const borderWidthProps = [
  'borderWidth',
  'borderTopWidth',
  'borderBottomWidth',
  'borderLeftWidth',
  'borderRightWidth'
];

const borderRadiusProps = [
  'borderRadius',
  'borderTopLeftRadius',
  'borderTopRightRadius',
  'borderBottomLeftRadius',
  'borderbottomRightRadius'
];

const propsSet = new Set(
  spacingProps.concat(
    sizeProps,
    colorProps,
    borderStyleProps,
    borderWidthProps,
    borderRadiusProps,
    'fontSize',
    'textAlign',
    'display'
  )
);

// Function to construct the prop types object
const makePropTypes = () => {
  const propTypes = {
    fontSize: scalePropType,
    textAlign: sizePropType,
    display: sizePropType
  };
  for (let prop of spacingProps.concat(borderWidthProps, borderRadiusProps)) {
    propTypes[prop] = scalePropType;
  }
  for (let prop of colorProps.concat(borderStyleProps)) {
    propTypes[prop] = PropTypes.string;
  }
  for (let prop of sizeProps) {
    propTypes[prop] = sizePropType;
  }
  return propTypes;
};

const styledPropTypes = makePropTypes();

// Fela rule which turns component props into a style object
const propsRule = props =>
  Object.keys(props)
    .filter(prop => propsSet.has(prop))
    .reduce((o, prop) => ((o[prop] = props[prop]), o), {});

// Static breakpoints
const bp = [null, `tablet`, `desktop`];

// Ensure value is an array
const arr = n => (Array.isArray(n) ? n : [n]);

// Tranform value array into object array
// [32, 64] into [{margin: 32}, {margin: 64}]
const dec = props => val =>
  arr(props).reduce((acc, prop) => ((acc[prop] = val), acc), {});

// Transform object array into breakpoint syntax
// [{margin: 32}, {margin: 64}] into [{margin: 32}, {"@media screen and (min-width: )": {margin: 64}}]
const media = (d, i) =>
  d !== undefined && d !== null ? (bp[i] ? { [bp[i]]: d } : d) : null;

// Recursive object merge
const merge = (a, b) =>
  Object.assign(
    {},
    a,
    b,
    Object.keys(b).reduce(
      (obj, key) =>
        Object.assign(obj, {
          [key]:
            a[key] !== null && typeof a[key] === 'object'
              ? merge(a[key], b[key])
              : b[key]
        }),
      {}
    )
  );

const processRules = customRules => {
  let rules = {
    ...customRules
  };

  // Expand shorthand spacing properties
  ['padding', 'margin'].forEach(property => {
    if (rules.hasOwnProperty(property)) {
      ['Top', 'Bottom', 'Left', 'Right'].forEach(position => {
        const attr = `${property}${position}`;
        // Don't overwrite pre-existing longhand properties
        if (!rules[attr]) {
          rules[attr] = rules[property];
        }
      });
      delete rules[property];
    }
  });

  // Expand custom shorthand spacing properties
  Object.keys(rules)
    .filter(property => Object.keys(shorthandSpacingProps).includes(property))
    .forEach(property => {
      Object.assign(
        rules,
        shorthandSpacingProps[property].reduce((a, b) => {
          a[b] = rules[property];
          return a;
        }, {})
      );

      delete rules[property];
    });

  // Convert spacing scales
  rules = Object.keys(rules)
    .filter(property => spacingProps.includes(property))
    .map(property => {
      const propValues = arr(rules[property])
        .map(val => theme.space[val] || val)
        .map(dec(property))
        .map(media)
        .reduce(merge, {});

      delete rules[property];

      return propValues;
    })
    .reduce(merge, rules);

  // Convert colors to theme
  rules = Object.keys(rules)
    .filter(property => colorProps.includes(property))
    .map(property => {
      const propValues = arr(rules[property])
        .map(val => {
          // Handle nested '.' syntax
          if (val && val.includes('.')) {
            // Attempt to access nested values, otherwise return what was passed
            try {
              return val
                .split('.')
                .reduce((acc, part) => acc[part], theme.colors);
            } catch (e) {
              return val;
            }
          } else if (typeof theme.colors[val] === 'string') {
            return theme.colors[val];
          }
          return val;
        })
        .map(dec(property))
        .map(media)
        .reduce(merge, {});

      delete rules[property];

      return propValues;
    })
    .reduce(merge, rules);

  // font-size
  if (rules.fontSize) {
    let fontSize = arr(rules.fontSize)
      .map(val => theme.fontSizes[val] || val)
      .map(dec('fontSize'))
      .map(media)
      .reduce(merge, {});

    delete rules.fontSize;

    rules = merge(rules, fontSize);
  }

  // display
  if (rules.display) {
    let display = arr(rules.display)
      .map(dec('display'))
      .map(media)
      .reduce(merge, {});

    delete rules.display;

    rules = merge(rules, display);
  }

  return rules;
};

const emptyRule = () => ({});

const makeStyledRule = (rule = emptyRule) => {
  const combinedRules = combineRules(rule, propsRule);
  return (props, renderer) => processRules(combinedRules(props, renderer));
};

function createStyledComponent(rule, ...rest) {
  const styledRule = makeStyledRule(rule);
  const Component = createComponent(styledRule, ...rest);
  Component.propTypes = styledPropTypes;
  return Component;
}

export default createStyledComponent;

export {
  colorProps,
  spacingProps,
  sizeProps,
  borderStyleProps,
  borderWidthProps,
  borderRadiusProps
};
