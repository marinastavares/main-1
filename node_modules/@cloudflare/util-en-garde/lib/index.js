"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isLeft", {
  enumerable: true,
  get: function get() {
    return _Either.isLeft;
  }
});
Object.defineProperty(exports, "isRight", {
  enumerable: true,
  get: function get() {
    return _Either.isRight;
  }
});
exports.t = exports.eg = exports.ObjectCodec = exports.Codec = exports.EnGardeAssertionError = void 0;

var t = _interopRequireWildcard(require("io-ts"));

exports.t = t;

var _typeHelpers = require("./type-helpers");

var _Either = require("fp-ts/lib/Either");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EnGardeAssertionError = /*#__PURE__*/function (_Error) {
  _inherits(EnGardeAssertionError, _Error);

  function EnGardeAssertionError(errors) {
    var _this;

    _classCallCheck(this, EnGardeAssertionError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EnGardeAssertionError).call(this));
    _this.errors = errors;
    Object.setPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this)), EnGardeAssertionError.prototype);
    return _this;
  }

  return EnGardeAssertionError;
}(_wrapNativeSuper(Error));

exports.EnGardeAssertionError = EnGardeAssertionError;

var Codec = /*#__PURE__*/function (_t$Type) {
  _inherits(Codec, _t$Type);

  function Codec(ioTsCodec) {
    var _this2;

    _classCallCheck(this, Codec);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Codec).call(this, ioTsCodec.name, ioTsCodec.is, ioTsCodec.validate, ioTsCodec.encode));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), "assertDecode", function (value) {
      var result = _this2.decode(value);

      if (result._tag === 'Left') throw new EnGardeAssertionError(result.left);
      return result.right;
    });

    return _this2;
  }

  _createClass(Codec, [{
    key: "optional",
    get: function get() {
      return new Codec(t.union([this, t.undefined]));
    }
  }]);

  return Codec;
}(t.Type);

exports.Codec = Codec;

var ObjectCodec = /*#__PURE__*/function (_t$InterfaceType) {
  _inherits(ObjectCodec, _t$InterfaceType);

  function ObjectCodec(ioTsCodec) {
    var _this3;

    _classCallCheck(this, ObjectCodec);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ObjectCodec).call(this, ioTsCodec.name, // these MUST be cast as any because the types don't line up and that's
    // what we want since we're enabling optional keys
    function (value) {
      return _typeof(value) === 'object' && value !== null && Object.keys(ioTsCodec.props).every(function (key) {
        return ioTsCodec.props[key].is((0, _typeHelpers.hasProperties)(value, key) ? value[key] : undefined);
      });
    }, ioTsCodec.validate, ioTsCodec.encode, ioTsCodec.props));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), "assertDecode", function (value) {
      var result = _this3.decode(value);

      if (result._tag === 'Left') throw new EnGardeAssertionError(result.left);
      return result.right;
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this3)), "create", function (value) {
      return _this3.assertDecode(value);
    });

    return _this3;
  }

  _createClass(ObjectCodec, [{
    key: "optional",
    get: function get() {
      return new Codec(t.union([this, t.undefined]));
    }
  }]);

  return ObjectCodec;
}(t.InterfaceType);

exports.ObjectCodec = ObjectCodec;
var primitiveCodecs = {
  string: new Codec(t.string),
  number: new Codec(t.number),
  boolean: new Codec(t.boolean),
  null: new Codec(t.null),
  undefined: new Codec(t.undefined),
  any: new Codec(t.any),
  unknown: new Codec(t.unknown)
};

var wrapHigherOrderCodec = function wrapHigherOrderCodec(higherOrderCodec) {
  return function () {
    return new Codec(higherOrderCodec.apply(void 0, arguments));
  };
};

var higherOrderCodecs = {
  // Using a special type for object which enables optional keys
  object: function object(p, name) {
    return new ObjectCodec(t.type(p, name));
  },
  // Unfortunately tuple type inference does not work with our HOC wrapper.
  // so we need to explicitly define this here.
  tuple: function tuple(codecs, name) {
    return new Codec(t.tuple(codecs, name));
  },
  intersection: function intersection(codecs, name) {
    return new Codec(t.intersection(codecs, name));
  },
  brand: function brand(name, base, predicate) {
    return new Codec(t.brand(base, predicate, name));
  },
  enum: function _enum(e) {
    var keyLiterals = (0, _typeHelpers.objectKeys)(e).map(function (k) {
      return t.literal(e[k]);
    });

    if ((0, _typeHelpers.hasAtLeastTwo)(keyLiterals)) {
      return new Codec(t.union(keyLiterals));
    }

    if (keyLiterals.length === 1) {
      return new Codec(keyLiterals[0]);
    }

    return new Codec(t.undefined);
  },
  instanceof: function _instanceof(c) {
    return new Codec(new t.Type("instanceof ".concat(c.name), function (value) {
      return value instanceof c;
    }, function (value, context) {
      return value instanceof c ? t.success(value) : t.failure(value, context);
    }, function (a) {
      return a;
    }));
  },
  // decorates an InterfaceType like eg.exact,
  // but fails validation if keySet of target is not equivalent to codec's
  exactStrict: function exactStrict(wrappedInterfaceType) {
    var wrappedKeySet = new Set(Object.keys(wrappedInterfaceType.props)); // ensure every key in u exists in the codec

    var guard = function guard(u) {
      return wrappedInterfaceType.is(u) && Object.keys(u).every(function (key) {
        return wrappedKeySet.has(key);
      });
    };

    var extraKeys = function extraKeys(obj) {
      return Object.keys(obj).filter(function (key) {
        return !wrappedKeySet.has(key);
      });
    };

    var extraKeyContextEntries = function extraKeyContextEntries(keys, obj) {
      return keys.map(function (key) {
        return {
          key: key,
          actual: obj[key],
          type: t.undefined
        };
      });
    };

    return new ObjectCodec(new t.InterfaceType("exactStrict(".concat(wrappedInterfaceType.name, ")"), guard, function (unknownValue, context) {
      var decoded = wrappedInterfaceType.validate(unknownValue, context);

      if (decoded._tag === 'Right') {
        var ks = extraKeys(decoded.right);
        return ks.length === 0 ? t.success(decoded.right) : t.failure(unknownValue, _toConsumableArray(context).concat(_toConsumableArray(extraKeyContextEntries(ks, decoded.right))), 'found extra keys not present in codec');
      } else {
        // wrapped codec's validation failed
        // include wrapped codec failures, as well as any extra keys
        return t.failure(unknownValue, _toConsumableArray(context).concat(_toConsumableArray(decoded.left.reduce( // poor man's flat map
        function (acc, err) {
          return _toConsumableArray(acc).concat(_toConsumableArray(err.context));
        }, [])), _toConsumableArray(eg.record(eg.string, eg.any).is(unknownValue) ? extraKeyContextEntries(extraKeys(unknownValue), unknownValue) : [])));
      }
    }, wrappedInterfaceType.encode, wrappedInterfaceType.props));
  },
  // The types for these higher order codecs work with simple hoc wrapper
  array: wrapHigherOrderCodec(t.array),
  union: wrapHigherOrderCodec(t.union),
  record: wrapHigherOrderCodec(t.record),
  partial: wrapHigherOrderCodec(t.partial),
  literal: wrapHigherOrderCodec(t.literal),
  exact: wrapHigherOrderCodec(t.exact)
};

var isEmptyArray = function isEmptyArray(value) {
  return Array.isArray(value) && value.length === 0;
};

var helpers = {
  /**
   * Picks a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
   *
   * @param codec Codec to pick from
   * @param keys Keys to pick
   * @returns Subset codec that only has 'keys'.
   */
  pick: function pick(codec, keys) {
    var props = codec.props;
    return eg.object(keys.reduce(function (acc, key) {
      acc[key] = props[key];
      return acc;
    }, {}));
  },

  /**
   * Omits a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
   *
   * @param codec Codec to omit from
   * @param keys Keys to omit
   * @returns Subset codec without 'keys'.
   */
  omit: function omit(codec, keys) {
    var props = _objectSpread({}, codec.props);

    return eg.object(keys.reduce(function (acc, key) {
      delete acc[key];
      return acc;
    }, props));
  },

  /**
   * Creates union-of-literals LiteralType codec from ObjectCodec.
   *
   * @param Object codec
   * @returns LiteralType of keys, where keys are keyof codec.
   */
  keyOf: function keyOf(codec) {
    var props = codec.props;
    var keyLiterals = (0, _typeHelpers.objectKeys)(props).map(function (k) {
      return t.literal(k);
    });

    if ((0, _typeHelpers.hasAtLeastTwo)(keyLiterals)) {
      return new Codec(t.union(keyLiterals));
    }

    if (keyLiterals.length === 1) {
      return new Codec(keyLiterals[0]);
    }

    return new Codec(t.undefined);
  },
  // io-ts doesn't support creating an empty tuple or an array of type never
  // so we're creating a custom codec to represent this.
  emptyArray: new Codec(new t.Type('[]', isEmptyArray, function (value, context) {
    return isEmptyArray(value) ? t.success(value) : t.failure(value, context);
  }, t.identity))
};

var eg = _objectSpread({}, primitiveCodecs, higherOrderCodecs, helpers); // re-export io-ts lib


exports.eg = eg;