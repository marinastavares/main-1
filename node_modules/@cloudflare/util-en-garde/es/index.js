function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as t from 'io-ts';
import { objectKeys, hasAtLeastTwo, hasProperties } from './type-helpers';
/**
 * Why does this wrapper exist?
 *
 * `io-ts` is awesome and super powerful, but the API leaves some things to be
 * desired. It was designed to be used with `fp-ts` which is a library for
 * functional programming patterns in TypeScipt. The resulting type on the
 * "decode" method is an Either which is great to work with when using `fp-ts`,
 * but is otherwise cumbersome.
 *
 * By introducing an `assert` method, we can guarantee the function will always
 * return the decoded type by throwing an error if it fails to decode. With
 * promises we can easily chain an assertion and the promise will reject if
 * the data fails to decode.
 *
 * The other main thing this wrapper seeks to address is the clunkiness of
 * defining objects.
 *
 * If you want to declare an object in io-ts, it looks like this:
 *
 * const person = t.type({ firstName: t.string, lastName: t.string })
 *
 * 'type' here is not obvious that it is representing an object, but that's
 * not the only issue. If you want to make one of the keys optional, you must
 * manually union the type with t.undefined.
 *
 * const person = t.type({
 *   firstName: t.string,
 *   lastName: t.union([t.string, t.undefined])
 * })
 *
 * This isn't so bad that it warrants a wrapper, but it could be improved
 * upon. The real pain is that when deriving types from this, the 'optional'
 * key isn't actually optional.
 *
 * // { firstName: string, lastName: string | undefined }
 * type Person = t.TypeOf<typeof person>
 *
 * Note that lastName does *NOT* have a question mark after it marking it as
 * optional. If you wanted to now declare a variable with this type, you MUST
 * provide the lastName key, even if the value is undefined.
 *
 * const p: Person = { firstName: "Kevin", lastName: undefined }
 *
 * This is where things get really clunky. The solution according to the docs
 * is to separate your optional keys (with t.partial) from your required keys
 * and then intersect the two types together.
 *
 * const person = t.intersection([
 *   t.type({
 *     firstName: t.string,
 *   }),
 *   t.partial({
 *     lastName: t.string
 *   })
 * ])
 *
 * // Now this is correct
 * // { firstName: string, lastName?: string | undefined }
 * type Person = t.TypeOf<typeof person>
 *
 * This wrapper provides a much nicer API for this *very* common scenario
 * addressing the aforementioned quirks of io-ts.
 *
 * const person = eg.object({
 *   firstName: eg.string
 *   lastName: eg.string.optional
 * })
 *
 * // { firstName: string, lastName?: string | undefined }
 * type Person = TypeFromCodec<typeof person>
 *
 * The `optional` property unions the codec with the `undefined` codec, and the
 * type information that is derived handles this automatically.
 */

export class EnGardeAssertionError extends Error {
  constructor(errors) {
    super();
    this.errors = errors;
    Object.setPrototypeOf(this, EnGardeAssertionError.prototype);
  }

}
export class Codec extends t.Type {
  constructor(ioTsCodec) {
    super(ioTsCodec.name, ioTsCodec.is, ioTsCodec.validate, ioTsCodec.encode);

    _defineProperty(this, "assertDecode", value => {
      const result = this.decode(value);
      if (result._tag === 'Left') throw new EnGardeAssertionError(result.left);
      return result.right;
    });
  }

  get optional() {
    return new Codec(t.union([this, t.undefined]));
  }

}
export class ObjectCodec extends t.InterfaceType {
  constructor(ioTsCodec) {
    super(ioTsCodec.name, // these MUST be cast as any because the types don't line up and that's
    // what we want since we're enabling optional keys
    value => typeof value === 'object' && value !== null && Object.keys(ioTsCodec.props).every(key => ioTsCodec.props[key].is(hasProperties(value, key) ? value[key] : undefined)), ioTsCodec.validate, ioTsCodec.encode, ioTsCodec.props);

    _defineProperty(this, "assertDecode", value => {
      const result = this.decode(value);
      if (result._tag === 'Left') throw new EnGardeAssertionError(result.left);
      return result.right;
    });

    _defineProperty(this, "create", value => this.assertDecode(value));
  }

  get optional() {
    return new Codec(t.union([this, t.undefined]));
  }

}
const primitiveCodecs = {
  string: new Codec(t.string),
  number: new Codec(t.number),
  boolean: new Codec(t.boolean),
  null: new Codec(t.null),
  undefined: new Codec(t.undefined),
  any: new Codec(t.any),
  unknown: new Codec(t.unknown)
};

const wrapHigherOrderCodec = higherOrderCodec => (...hocParams) => new Codec(higherOrderCodec(...hocParams));

const higherOrderCodecs = {
  // Using a special type for object which enables optional keys
  object: (p, name) => new ObjectCodec(t.type(p, name)),
  // Unfortunately tuple type inference does not work with our HOC wrapper.
  // so we need to explicitly define this here.
  tuple: (codecs, name) => new Codec(t.tuple(codecs, name)),
  intersection: (codecs, name) => new Codec(t.intersection(codecs, name)),
  brand: (name, base, predicate) => new Codec(t.brand(base, predicate, name)),
  enum: e => {
    const keyLiterals = objectKeys(e).map(k => t.literal(e[k]));

    if (hasAtLeastTwo(keyLiterals)) {
      return new Codec(t.union(keyLiterals));
    }

    if (keyLiterals.length === 1) {
      return new Codec(keyLiterals[0]);
    }

    return new Codec(t.undefined);
  },
  instanceof: c => {
    return new Codec(new t.Type(`instanceof ${c.name}`, value => value instanceof c, (value, context) => value instanceof c ? t.success(value) : t.failure(value, context), a => a));
  },
  // decorates an InterfaceType like eg.exact,
  // but fails validation if keySet of target is not equivalent to codec's
  exactStrict: wrappedInterfaceType => {
    const wrappedKeySet = new Set(Object.keys(wrappedInterfaceType.props)); // ensure every key in u exists in the codec

    const guard = u => wrappedInterfaceType.is(u) && Object.keys(u).every(key => wrappedKeySet.has(key));

    const extraKeys = obj => Object.keys(obj).filter(key => !wrappedKeySet.has(key));

    const extraKeyContextEntries = (keys, obj) => keys.map(key => ({
      key,
      actual: obj[key],
      type: t.undefined
    }));

    return new ObjectCodec(new t.InterfaceType(`exactStrict(${wrappedInterfaceType.name})`, guard, (unknownValue, context) => {
      const decoded = wrappedInterfaceType.validate(unknownValue, context);

      if (decoded._tag === 'Right') {
        const ks = extraKeys(decoded.right);
        return ks.length === 0 ? t.success(decoded.right) : t.failure(unknownValue, [...context, ...extraKeyContextEntries(ks, decoded.right)], 'found extra keys not present in codec');
      } else {
        // wrapped codec's validation failed
        // include wrapped codec failures, as well as any extra keys
        return t.failure(unknownValue, [...context, ...decoded.left.reduce( // poor man's flat map
        (acc, err) => [...acc, ...err.context], []), ...(eg.record(eg.string, eg.any).is(unknownValue) ? extraKeyContextEntries(extraKeys(unknownValue), unknownValue) : [])]);
      }
    }, wrappedInterfaceType.encode, wrappedInterfaceType.props));
  },
  // The types for these higher order codecs work with simple hoc wrapper
  array: wrapHigherOrderCodec(t.array),
  union: wrapHigherOrderCodec(t.union),
  record: wrapHigherOrderCodec(t.record),
  partial: wrapHigherOrderCodec(t.partial),
  literal: wrapHigherOrderCodec(t.literal),
  exact: wrapHigherOrderCodec(t.exact)
};

const isEmptyArray = value => Array.isArray(value) && value.length === 0;

const helpers = {
  /**
   * Picks a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
   *
   * @param codec Codec to pick from
   * @param keys Keys to pick
   * @returns Subset codec that only has 'keys'.
   */
  pick: (codec, keys) => {
    const props = codec.props;
    return eg.object(keys.reduce((acc, key) => {
      acc[key] = props[key];
      return acc;
    }, {}));
  },

  /**
   * Omits a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
   *
   * @param codec Codec to omit from
   * @param keys Keys to omit
   * @returns Subset codec without 'keys'.
   */
  omit: (codec, keys) => {
    const props = _objectSpread({}, codec.props);

    return eg.object(keys.reduce((acc, key) => {
      delete acc[key];
      return acc;
    }, props));
  },

  /**
   * Creates union-of-literals LiteralType codec from ObjectCodec.
   *
   * @param Object codec
   * @returns LiteralType of keys, where keys are keyof codec.
   */
  keyOf: codec => {
    const props = codec.props;
    const keyLiterals = objectKeys(props).map(k => t.literal(k));

    if (hasAtLeastTwo(keyLiterals)) {
      return new Codec(t.union(keyLiterals));
    }

    if (keyLiterals.length === 1) {
      return new Codec(keyLiterals[0]);
    }

    return new Codec(t.undefined);
  },
  // io-ts doesn't support creating an empty tuple or an array of type never
  // so we're creating a custom codec to represent this.
  emptyArray: new Codec(new t.Type('[]', isEmptyArray, (value, context) => isEmptyArray(value) ? t.success(value) : t.failure(value, context), t.identity))
};
export const eg = _objectSpread({}, primitiveCodecs, higherOrderCodecs, helpers); // re-export io-ts lib

export { t }; // re-export fp-ts

export { isLeft, isRight } from 'fp-ts/lib/Either';