import * as t from 'io-ts';
import { Compute, ValueOf } from './type-helpers';
/**
 * Why does this wrapper exist?
 *
 * `io-ts` is awesome and super powerful, but the API leaves some things to be
 * desired. It was designed to be used with `fp-ts` which is a library for
 * functional programming patterns in TypeScipt. The resulting type on the
 * "decode" method is an Either which is great to work with when using `fp-ts`,
 * but is otherwise cumbersome.
 *
 * By introducing an `assert` method, we can guarantee the function will always
 * return the decoded type by throwing an error if it fails to decode. With
 * promises we can easily chain an assertion and the promise will reject if
 * the data fails to decode.
 *
 * The other main thing this wrapper seeks to address is the clunkiness of
 * defining objects.
 *
 * If you want to declare an object in io-ts, it looks like this:
 *
 * const person = t.type({ firstName: t.string, lastName: t.string })
 *
 * 'type' here is not obvious that it is representing an object, but that's
 * not the only issue. If you want to make one of the keys optional, you must
 * manually union the type with t.undefined.
 *
 * const person = t.type({
 *   firstName: t.string,
 *   lastName: t.union([t.string, t.undefined])
 * })
 *
 * This isn't so bad that it warrants a wrapper, but it could be improved
 * upon. The real pain is that when deriving types from this, the 'optional'
 * key isn't actually optional.
 *
 * // { firstName: string, lastName: string | undefined }
 * type Person = t.TypeOf<typeof person>
 *
 * Note that lastName does *NOT* have a question mark after it marking it as
 * optional. If you wanted to now declare a variable with this type, you MUST
 * provide the lastName key, even if the value is undefined.
 *
 * const p: Person = { firstName: "Kevin", lastName: undefined }
 *
 * This is where things get really clunky. The solution according to the docs
 * is to separate your optional keys (with t.partial) from your required keys
 * and then intersect the two types together.
 *
 * const person = t.intersection([
 *   t.type({
 *     firstName: t.string,
 *   }),
 *   t.partial({
 *     lastName: t.string
 *   })
 * ])
 *
 * // Now this is correct
 * // { firstName: string, lastName?: string | undefined }
 * type Person = t.TypeOf<typeof person>
 *
 * This wrapper provides a much nicer API for this *very* common scenario
 * addressing the aforementioned quirks of io-ts.
 *
 * const person = eg.object({
 *   firstName: eg.string
 *   lastName: eg.string.optional
 * })
 *
 * // { firstName: string, lastName?: string | undefined }
 * type Person = TypeFromCodec<typeof person>
 *
 * The `optional` property unions the codec with the `undefined` codec, and the
 * type information that is derived handles this automatically.
 */
declare type KeysWithValueType<O, T> = {
    [Key in keyof O]: Key;
}[Exclude<keyof O, KeysWithoutValueType<O, T>>];
declare type KeysWithoutValueType<O, T> = {
    [Key in keyof O]: T extends O[Key] ? never : Key;
}[keyof O];
declare type RepackKeys<T> = {
    [Key in keyof T]: T[Key];
} & {};
declare type EnableOptionalKeys<T> = RepackKeys<{
    [MandatoryKey in KeysWithoutValueType<T, undefined>]: T[MandatoryKey];
} & {
    [OptionalKey in KeysWithValueType<T, undefined>]?: T[OptionalKey];
}>;
export declare class EnGardeAssertionError extends Error {
    errors: t.Errors;
    constructor(errors: t.Errors);
}
declare type IoTsCodec = t.Any;
export declare class Codec<C extends IoTsCodec> extends t.Type<t.TypeOf<C>, t.OutputOf<C>, t.InputOf<C>> {
    constructor(ioTsCodec: C);
    assertDecode: (value: unknown) => t.TypeOf<C>;
    get optional(): Codec<t.UnionC<[this, t.UndefinedC]>>;
}
export declare class ObjectCodec<P extends t.Props> extends t.InterfaceType<P, EnableOptionalKeys<{
    [K in keyof P]: t.TypeOf<P[K]>;
}>, EnableOptionalKeys<{
    [K in keyof P]: t.OutputOf<P[K]>;
}>, unknown> {
    constructor(ioTsCodec: t.TypeC<P>);
    assertDecode: (value: unknown) => { [Key in keyof ({ [MandatoryKey in KeysWithoutValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]: { [K in keyof P]: t.TypeOf<P[K]>; }[MandatoryKey]; } & { [OptionalKey in KeysWithValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]?: { [K in keyof P]: t.TypeOf<P[K]>; }[OptionalKey] | undefined; })]: ({ [MandatoryKey in KeysWithoutValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]: { [K in keyof P]: t.TypeOf<P[K]>; }[MandatoryKey]; } & { [OptionalKey in KeysWithValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]?: { [K in keyof P]: t.TypeOf<P[K]>; }[OptionalKey] | undefined; })[Key]; };
    create: (value: TypeFromCodec<typeof this>) => { [Key in keyof ({ [MandatoryKey in KeysWithoutValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]: { [K in keyof P]: t.TypeOf<P[K]>; }[MandatoryKey]; } & { [OptionalKey in KeysWithValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]?: { [K in keyof P]: t.TypeOf<P[K]>; }[OptionalKey] | undefined; })]: ({ [MandatoryKey in KeysWithoutValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]: { [K in keyof P]: t.TypeOf<P[K]>; }[MandatoryKey]; } & { [OptionalKey in KeysWithValueType<{ [K in keyof P]: t.TypeOf<P[K]>; }, undefined>]?: { [K in keyof P]: t.TypeOf<P[K]>; }[OptionalKey] | undefined; })[Key]; };
    get optional(): Codec<t.UnionC<[this, t.UndefinedC]>>;
}
export declare type TypeFromCodec<T extends IoTsCodec> = t.TypeOf<T>;
export declare const eg: {
    /**
     * Picks a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
     *
     * @param codec Codec to pick from
     * @param keys Keys to pick
     * @returns Subset codec that only has 'keys'.
     */
    pick: <C extends ObjectCodec<any>, Keys extends keyof C["props"]>(codec: C, keys: Keys[]) => ObjectCodec<{ [key in Keys]: C["props"][key]; }>;
    /**
     * Omits a subset of ObjectCodec and returns new ObjectCodec. The subset is determined by keys array.
     *
     * @param codec Codec to omit from
     * @param keys Keys to omit
     * @returns Subset codec without 'keys'.
     */
    omit: <C_1 extends ObjectCodec<any>, Keys_1 extends keyof C_1["props"]>(codec: C_1, keys: Keys_1[]) => ObjectCodec<Compute<Omit<C_1["props"], Keys_1>>>;
    /**
     * Creates union-of-literals LiteralType codec from ObjectCodec.
     *
     * @param Object codec
     * @returns LiteralType of keys, where keys are keyof codec.
     */
    keyOf: <C_2 extends ObjectCodec<any>>(codec: C_2) => Codec<t.LiteralType<Extract<keyof C_2["props"], string>>>;
    emptyArray: Codec<t.Type<[], [], unknown>>;
    object: <P extends t.Props>(p: P, name?: string | undefined) => ObjectCodec<P>;
    tuple: <Codecs extends [t.Any, ...t.Any[]]>(codecs: Codecs, name?: string | undefined) => Codec<t.TupleC<Codecs>>;
    intersection: <Codecs_1 extends [t.Any, t.Any, ...t.Any[]]>(codecs: Codecs_1, name?: string | undefined) => Codec<t.IntersectionC<Codecs_1>>;
    brand: <Name extends string, BaseCodec extends Codec<any>>(name: Name, base: BaseCodec, predicate: (value: TypeFromCodec<BaseCodec>) => boolean) => Codec<t.BrandC<BaseCodec, { [N in Name]: symbol; }>>;
    enum: <Enum extends {
        [key: string]: string | number;
    }>(e: Enum) => Codec<t.LiteralType<ValueOf<Enum>>>;
    instanceof: <Constructor extends new (...args: any[]) => any>(c: Constructor) => Codec<t.Type<InstanceType<Constructor>, InstanceType<Constructor>, unknown>>;
    exactStrict: <P_1 extends t.Props, IT extends t.InterfaceType<P_1, any, any, unknown>>(wrappedInterfaceType: IT) => ObjectCodec<IT["props"]>;
    array: <C_3 extends t.Mixed>(codec: C_3, name?: string | undefined) => Codec<t.ArrayC<C_3>>;
    union: <CS extends [t.Mixed, t.Mixed, ...t.Mixed[]]>(codecs: CS, name?: string | undefined) => Codec<t.UnionC<CS>>;
    record: <D extends t.Mixed, C_4 extends t.Mixed>(domain: D, codomain: C_4, name?: string | undefined) => Codec<t.RecordC<D, C_4>>;
    partial: <P_2 extends t.Props>(props: P_2, name?: string | undefined) => Codec<t.PartialC<P_2>>;
    literal: <V extends string | number | boolean>(value: V, name?: string | undefined) => Codec<t.LiteralC<V>>;
    exact: <C_5 extends t.HasProps>(codec: C_5, name?: string | undefined) => Codec<t.ExactC<C_5>>;
    string: Codec<t.StringC>;
    number: Codec<t.NumberC>;
    boolean: Codec<t.BooleanC>;
    null: Codec<t.NullC>;
    undefined: Codec<t.UndefinedC>;
    any: Codec<t.AnyC>;
    unknown: Codec<t.UnknownC>;
};
export { t };
export { isLeft, isRight } from 'fp-ts/lib/Either';
