/**
 * Force TS to load a type that has not been computed
 * (to resolve composed types that TS hasn't resolved).
 * https://pirix-gh.github.io/ts-toolbelt/modules/_any_compute_.html
 *
 * @example
 * // becomes {foo: string, baz: boolean}
 * type Foo = Compute<{bar: string} & {baz: boolean}>
 */
export declare type Compute<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
} & {};
/**
 *  Generates the typings for usage with Object.keys
 *
 *  @example
 *  const Locations = { "Cina": "Austin", "John": "Austin", "Kevin": "Austin", "Nicky": "San Francisco", "Robert": "San Francisco" }
 *  const KeysFromLocations = objectKeys(Locations)
 */
export declare function objectKeys<T>(t: T): (keyof T)[];
/**
 * ValueOf: similar to keyof, but picks a value.
 *
 * @example
 * type Person = {
 *   name: string,
 *   phone: number | null
 * }
 *
 * type PhoneType = ValueOf<Person>; // string | number | null
 */
export declare type ValueOf<T> = T[keyof T];
export declare const hasAtLeastTwo: <T>(ts: T[]) => ts is [T, T, ...T[]];
export declare function hasProperties<T extends object, K extends string>(obj: T, ...keys: K[]): obj is T & {
    [J in K]: unknown;
};
